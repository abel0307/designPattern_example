第4章 接口隔离原则

4.1 接口隔离原则的定义
在讲接口隔离原则之前，先明确一下我们的主角——接口。接口分为两种：
● 实例接口（Object Interface），在Java中声明一个类，然后用new关键字产生一个实
例，它是对一个类型的事物的描述，这是一种接口。比如你定义Person这个类，然后使用
Person zhangSan=new Person()产生了一个实例，这个实例要遵从的标准就是Person这个
类，Person类就是zhangSan的接口。疑惑？看不懂？不要紧，那是因为让Java语言浸染的时间
太长了，只要知道从这个角度来看，Java中的类也是一种接口。
● 类接口（Class Interface），Java中经常使用的interface关键字定义的接口。
主角已经定义清楚了，那什么是隔离呢？
它有两种定义，如下所示：
● Clients should not be forced to depend upon interfaces that they don't use.（客户端不应该依
赖它不需要的接口。）
● The dependency of one class to another one should depend on the smallest possible interface.
（类间的依赖关系应该建立在最小的接口上。）

新事物的定义一般都比较难理解，晦涩难懂是正常的。我们把这两个定义剖析一下，先
说第一种定义：“客户端不应该依赖它不需要的接口”，那依赖什么？依赖它需要的接口，客
户端需要什么接口就提供什么接口，把不需要的接口剔除掉，那就需要对接口进行细化，保
证其纯洁性；再看第二种定义：“类间的依赖关系应该建立在最小的接口上”，它要求是最小
的接口，也是要求接口细化，接口纯洁，与第一个定义如出一辙，只是一个事物的两种不同
描述。
我们可以把这两个定义概括为一句话：建立单一接口，不要建立臃肿庞大的接口。再通
俗一点讲：接口尽量细化，同时接口中的方法尽量少。看到这里大家有可能要疑惑了，这与
单一职责原则不是相同的吗？错，接口隔离原则与单一职责的审视角度是不相同的，单一职
责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要
求接口的方法尽量少。例如一个接口的职责可能包含10个方法，这10个方法都放在一个接口
中，并且提供给多个模块访问，各个模块按照规定的权限来访问，在系统外通过文档约
束“不使用的方法不要访问”，按照单一职责原则是允许的，按照接口隔离原则是不允许的，
因为它要求“尽量使用多个专门的接口”。专门的接口指什么？就是指提供给每个模块的都应
该是单一接口，提供给几个模块就应该有几个接口，而不是建立一个庞大的臃肿的接口，容
纳所有的客户端访问。


4.3 保证接口的纯洁性
接口隔离原则是对接口进行规范约束，其包含以下4层含义：
● 接口要尽量小
这是接口隔离原则的核心定义，不出现臃肿的接口（Fat Interface），但是“小”是有限度
的，首先就是不能违反单一职责原则，什么意思呢？我们在单一职责原则中提到一个IPhone
的例子，在这里，我们使用单一职责原则把两个职责分解到两个接口中，类图如图4-3所
示。
图4-3 电话类图
仔细分析一下IConnectionManager接口是否还可以再继续拆分下去，挂电话有两种方
式：一种是正常的电话挂断，一种是电话异常挂机，比如突然没电了，通信当然就断了。这
两种方式的处理应该是不同的，为什么呢？正常挂电话，对方接受到挂机信号，计费系统也
就停止计费了，那手机没电了这种方式就不同了，它是信号丢失了，中继服务器检查到了，
然后通知计费系统停止计费，否则你的费用不是要疯狂地增长了吗？
思考到这里，我们是不是就要动手把IConnectionManager接口拆封成两个，一个接口是
负责连接，一个接口是负责挂电话？是要这样做吗？且慢，让我们再思考一下，如果拆分
了，那就不符合单一职责原则了，因为从业务逻辑上来讲，通信的建立和关闭已经是最小的
业务单位了，再细分下去就是对业务或是协议（其他业务逻辑）的拆分了。想想看，一个电
话要关心3G协议，要考虑中继服务器，等等，这个电话还怎么设计得出来呢？从业务层次
来看，这样的设计就是一个失败的设计。一个原则要拆，一个原则又不要拆，那该怎么办？
好办，根据接口隔离原则拆分接口时，首先必须满足单一职责原则。
● 接口要高内聚
什么是高内聚？高内聚就是提高接口、类、模块的处理能力，减少对外的交互。比如你
告诉下属“到奥巴马的办公室偷一个×××文件”，然后听到下属用坚定的口吻回答你：“是，保
证完成任务！”一个月后，你的下属还真的把×××文件放到你的办公桌上了，这种不讲任何条
件、立刻完成任务的行为就是高内聚的表现。具体到接口隔离原则就是，要求在接口中尽量
少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越
少，同时也有利于降低成本。
● 定制服务
一个系统或系统内的模块之间必然会有耦合，有耦合就要有相互访问的接口（并不一定
就是Java中定义的Interface，也可能是一个类或单纯的数据交换），我们设计时就需要为各
个访问者（即客户端）定制服务，什么是定制服务？定制服务就是单独为一个个体提供优良
的服务。我们在做系统设计时也需要考虑对系统之间或模块之间的接口采用定制服务。采用
定制服务就必然有一个要求：只提供访问者需要的方法，这是什么意思？我们举个例子来说
明，比如我们开发了一个图书管理系统，其中有一个查询接口，方便管理员查询图书，其类
图如图4-4所示。
图4-4 图书查询类图
在接口中定义了多个查询方法，分别可以按照作者、标题、出版社、分类进行查询，最
后还提供了混合查询方式。程序写好了，投产上线了，突然有一天发现系统速度非常慢，然
后就开始痛苦地分析，最终发现是访问接口中的complexSearch(Map map)方法并发量太大，
导致应用服务器性能下降，然后继续跟踪下去发现这些查询都是从公网上发起的，进一步分
析，找到问题：提供给公网（公网项目是另外一个项目组开发的）的查询接口和提供给系统
内管理人员的接口是相同的，都是IBookSearcher接口，但是权限不同，系统管理人员可以通
过接口的complexSearch方法查询到所有的书籍，而公网的这个方法是被限制的，不返回任何
值，在设计时通过口头约束，这个方法是不可被调用的，但是由于公网项目组的疏忽，这个
方法还是公布了出去，虽然不能返回结果，但是还是引起了应用服务器的性能巨慢的情况发
生，这就是一个臃肿接口引起性能故障的案例。
问题找到了，就需要把这个接口进行重构，将IBookSearcher拆分为两个接口，分别为两
个模块提供定制服务，修改后的类图如图4-5所示。
图4-5 修改后的图书查询类图
提供给管理人员的实现类同时实现了ISimpleBookSearcher和IComplexBookSearcher两个接
口，原有程序不用做任何改变，而提供给公网的接口变为ISimpleBookSearcher，只允许进行
简单的查询，单独为其定制服务，减少可能引起的风险。
● 接口设计是有限度的
接口的设计粒度越小，系统越灵活，这是不争的事实。但是，灵活的同时也带来了结构
的复杂化，开发难度增加，可维护性降低，这不是一个项目或产品所期望看到的，所以接口
设计一定要注意适度，这个“度”如何来判断呢？根据经验和常识判断，没有一个固化或可测
量的标准。


4.4 最佳实践
接口隔离原则是对接口的定义，同时也是对类的定义，接口和类尽量使用原子接口或原
子类来组装。但是，这个原子该怎么划分是设计模式中的一大难题，在实践中可以根据以下
几个规则来衡量：
● 一个接口只服务于一个子模块或业务逻辑；
● 通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到“满身筋骨
肉”，而不是“肥嘟嘟”的一大堆方法；
● 已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化
处理；
● 了解环境，拒绝盲从。每个项目或产品都有特定的环境因素，别看到大师是这样做的
你就照抄。千万别，环境不同，接口拆分的标准就不同。深入了解业务逻辑，最好的接口设
计就出自你的手中！
接口隔离原则和其他设计原则一样，都需要花费较多的时间和精力来进行设计和筹划，
但是它带来了设计的灵活性，让你可以在业务人员提出“无理”要求时轻松应付。贯彻使用接
口隔离原则最好的方法就是一个接口一个方法，保证绝对符合接口隔离原则（有可能不符合
单一职责原则），但你会采用吗？不会，除非你是疯子！那怎么才能正确地使用接口隔离原
则呢？答案是根据经验和常识决定接口的粒度大小，接口粒度太小，导致接口数据剧增，开
发人员呛死在接口的海洋里；接口粒度太大，灵活性降低，无法提供定制服务，给整体项目
带来无法预料的风险。