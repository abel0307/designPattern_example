第2章 里氏替换原则

2.1 爱恨纠葛的父子关系
在面向对象的语言中，继承是必不可少的、非常优秀的语言机制，它有如下优点：
● 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性；

● 提高代码的重用性；

● 子类可以形似父类，但又异于父类，“龙生龙，凤生凤，老鼠生来会打洞”是说子拥有
父的“种”，“世界上没有两片完全相同的叶子”是指明子与父的不同；

● 提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，君不见很多开源框架的
扩展接口都是通过继承父类来完成的；

● 提高产品或项目的开放性。


自然界的所有事物都是优点和缺点并存的，即使是鸡蛋，有时候也能挑出骨头来，继承的缺点如下：
● 继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法；

● 降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束；

● 增强了耦合性。当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在
缺乏规范的环境下，这种修改可能带来非常糟糕的结果??大段的代码需要重构。
Java使用extends关键字来实现继承，它采用了单一继承的规则，C++则采用了多重继承
的规则，一个子类可以继承多个父类。从整体上来看，利大于弊，怎么才能让“利”的因素发
挥最大的作用，同时减少“弊”带来的麻烦呢？解决方案是引入里氏替换原则（Liskov
Substitution Principle，LSP），什么是里氏替换原则呢？它有两种定义：
    ● 第一种定义，也是最正宗的定义：If for each object o1 of type S there is an object o2 of
type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is
substituted for o2 then S is a subtype of T.（如果对每一个类型为S的对象o1，都有类型为T的对
象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变
化，那么类型S是类型T的子类型。）
    ● 第二种定义：Functions that use pointers or references to base classes must be able to use
objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的
对象。）
第二个定义是最清晰明确的，通俗点讲，只要父类能出现的地方子类就可以出现，而且
替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但
是，反过来就不行了，有子类出现的地方，父类未必就能适应。


2.2 纠纷不断，规则压制
里氏替换原则为良好的继承定义了一个规范，一句简单的定义包含了4层含义。

1.子类必须完全实现父类的方法
我们在做系统设计时，经常会定义一个接口或抽象类，然后编码实现，调用类则直接传
入接口或抽象类，其实这里已经使用了里氏替换原则。

2.子类可以有自己的个性
子类当然可以有自己的行为和外观了，也就是方法和属性，那这里为什么要再提呢？是
因为里氏替换原则可以正着用，但是不能反过来用。在子类出现的地方，父类未必就可以胜
任。


3.覆盖或实现父类的方法时输入参数可以被放大
方法中的输入参数称为前置条件，这是什么意思呢？大家做过Web Service开发就应该知
道有一个“契约优先”的原则，也就是先定义出WSDL接口，制定好双方的开发协议，然后再
各自实现。里氏替换原则也要求制定一个契约，就是父类或接口，这种设计方法也叫做
Design by Contract（契约设计），与里氏替换原则有着异曲同工之妙。契约制定了，也就同
时制定了前置条件和后置条件，前置条件就是你要让我执行，就必须满足我的条件；后置条
件就是我执行完了需要反馈，标准是什么。


4. 覆写或实现父类的方法时输出结果可以被缩小
这是什么意思呢，父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆
写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一
个类型，要么S是T的子类，为什么呢？分两种情况，如果是覆写，父类和子类的同名方法的
输入参数是相同的，两个方法的范围值S小于等于T，这是覆写的要求，这才是重中之重，子
类覆写父类的方法，天经地义。如果是重载，则要求方法的输入参数类型或数量不相同，在
里氏替换原则要求下，就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这
个方法是不会被调用的，参考上面讲的前置条件。
采用里氏替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容
性。即使增加子类，原有的子类还可以继续运行。在实际项目中，每个子类对应不同的业务
含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑，非常完美！